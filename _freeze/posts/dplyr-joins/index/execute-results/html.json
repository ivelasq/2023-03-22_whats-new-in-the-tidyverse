{
  "hash": "726090a4905c6705041e88550ecff2b6",
  "result": {
    "markdown": "---\ntitle: \"*_join()\"\nsubtitle: \"dplyr 1.1.0\"\ndate: 2023-01-29\ncategories:\n   - \"dplyr\"\nimage: \"dplyr-join.png\"\nimage-alt: \"Text that says dplyr joins. An image of a line plot with lines of varying widths.\"\ndescription: \"dplyr 1.1.0 has relaxed assumptions for non-equi joins.\"\n---\n\n\nInstall dplyr 1.1.0 with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pak(\"cran/dplyr@1.1.0\")\n```\n:::\n\n\nLoad the package with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\nLet's create some data. In `transactions`, we have company IDs, years, and revenue. In `companies`, we have the company IDs and full company names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions <- tibble(\n  company = c(\"A\", \"A\", \"B\", \"B\"),\n  year = c(2019, 2020, 2021, 2023),\n  revenue = c(50, 4, 10, 12)\n)\n\ncompanies <- tibble(id = c(\"A\", \"B\"),\n                    name = c(\"Patagonia\", \"RStudio\"))\n```\n:::\n\n\n## `join_by()`\n\nSay you want to join these two tables. You've been able to do this in dplyr:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |> \n  inner_join(companies, by = c(company = \"id\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  company  year revenue name     \n  <chr>   <dbl>   <dbl> <chr>    \n1 A        2019      50 Patagonia\n2 A        2020       4 Patagonia\n3 B        2021      10 RStudio  \n4 B        2023      12 RStudio  \n```\n:::\n:::\n\n\nThis is a bit odd:\n\n* Using `=` not `==`\n* Using `c()`\n* `\"id\"` has to be in quotes\n\nWelcome `join_by()`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |> \n  inner_join(companies, by = join_by(company == id))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  company  year revenue name     \n  <chr>   <dbl>   <dbl> <chr>    \n1 A        2019      50 Patagonia\n2 A        2020       4 Patagonia\n3 B        2021      10 RStudio  \n4 B        2023      12 RStudio  \n```\n:::\n:::\n\n\nThis is a much more natural way of expressing this join.\n\n## Multiple matches\n\nRStudio became Posit in 2023. Now, let's add a column to track the change:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompanies <- tibble(\n  id = c(\"A\", \"B\", \"B\"),\n  since = c(1973, 2009, 2022),\n  name = c(\"Patagonia\", \"RStudio\", \"Posit\")\n)\n```\n:::\n\n\nWhat happens when we try to join the tables together?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfaulty <-\n  transactions |> \n  inner_join(companies, by = join_by(company == id))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in inner_join(transactions, companies, by = join_by(company == id)): Each row in `x` is expected to match at most 1 row in `y`.\nℹ Row 3 of `x` matches multiple rows.\nℹ If multiple matches are expected, set `multiple = \"all\"` to silence this\n  warning.\n```\n:::\n:::\n\n\nIn 2021, it joined `B` with both `RStudio` and `Posit`, creating multiple matches. We want to match with RStudio, but not with Posit (because the name hasn’t changed yet).\n\n## Inequality joins\n\ndplyr 1.1.0 has inequality joins: join expressions containing one of the following the inequality conditions `>=`, `>`, `<=`, or `<`.\n\nYou can think through the logic of what you would like with the `year` and `since` columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Only want a match if `year` is *after* the name change\n# `year[i] >= since`?\n2021 >= 2009\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n2021 >= 2022\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nNow, you can add an inequality condition to `join_by()`:\n\n```r\n`join_by(company == id, year >= since)\n```\n\nRunning it with the inequality join:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |>\n  inner_join(companies, join_by(company == id, year >= since))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 5\n  company  year revenue since name     \n  <chr>   <dbl>   <dbl> <dbl> <chr>    \n1 A        2019      50  1973 Patagonia\n2 A        2020       4  1973 Patagonia\n3 B        2021      10  2009 RStudio  \n4 B        2023      12  2009 RStudio  \n5 B        2023      12  2022 Posit    \n```\n:::\n:::\n\n\nYou're down to five! But, in 2023, you still have two matches. This is because the logic is true but not complete:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2023 >= 2009\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n2021 >= 2022\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n## Rolling joins\n\nYou can use rolling joins to find the 'closest' inequality match.\n\nYou prefer the Posit match over the RStudio match because 2022 is *closer* to the transaction year of 2023 than 2009 is. Wrap something in `closest()` to express this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |>\n  inner_join(companies, join_by(company == id, closest(year >= since)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  company  year revenue since name     \n  <chr>   <dbl>   <dbl> <dbl> <chr>    \n1 A        2019      50  1973 Patagonia\n2 A        2020       4  1973 Patagonia\n3 B        2021      10  2009 RStudio  \n4 B        2023      12  2022 Posit    \n```\n:::\n:::\n\n\n> `closest(year >= since)` finds all of the matches in `since` for a particular year, and then filters them down to only the closest match to that year. \n\n## Unmatched rows\n\nSay you add a new company to `transactions` but forget to add them to `companies`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions <- transactions |>\n  tibble::add_row(company = \"C\", year = 2023, revenue = 15)\n\ntransactions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  company  year revenue\n  <chr>   <dbl>   <dbl>\n1 A        2019      50\n2 A        2020       4\n3 B        2021      10\n4 B        2023      12\n5 C        2023      15\n```\n:::\n:::\n\n\nWhen you run your join, company C will disappear:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |>\n  inner_join(\n    companies, \n    join_by(company == id, closest(year >= since))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  company  year revenue since name     \n  <chr>   <dbl>   <dbl> <dbl> <chr>    \n1 A        2019      50  1973 Patagonia\n2 A        2020       4  1973 Patagonia\n3 B        2021      10  2009 RStudio  \n4 B        2023      12  2022 Posit    \n```\n:::\n:::\n\n\nYou can now catch this problem automatically by using a new quality control argument, `unmatched`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |>\n  inner_join(\n    companies, \n    join_by(company == id, closest(year >= since)),\n    unmatched = \"error\"\n  )\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `inner_join()`:\n! Each row of `x` must have a match in `y`.\nℹ Row 5 of `x` does not have a match.\n```\n:::\n:::\n\n\n::: {.callout-tip}\nHave you been wondering why Davis is using an `inner_join()` instead of a `left_join()`? You’d use a left_join() is to ensure that rows from x are always retained, so it wouldn’t make sense to error when rows from x are also unmatched. In an inner_join(), both inputs can potentially drop rows, so `unmatched = \"error\"` checks for unmatched rows in both inputs.\n:::\n\n## Overlap joins\n\nThese are special cases of inequality joins popular in time series and genomics.\n\n* `join_by(id, between(date, y_lower, y_upper))`: You have a date in one column in one table and a range of upper/lower bounds in the other table and want to match when values are in the range in the other table.\n* `join_by(id, overlaps(x_lower, x_upper, y_lower, y_upper))`: Now, you have two sets of ranges and if they overlap at all, they match.\n* `join_by(id, within(x_lower, x_upper, y_lower, y_upper))` or has to be completely inside the lower and upper of the other table\n\n## Cross joins\n\nCross joins match each row in x to every row in y, giving you the full Cartesian production.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncharacters <-\n  tibble::tribble(\n    ~person,         ~title,\n     \"Shiv\",    \"President\",\n  \"Kendall\",  \"Interim CEO\",\n    \"Logan\",          \"CEO\",\n      \"Tom\", \"Head of News\",\n    \"Roman\",          \"COO\"\n  )\n\nalliances <-\n  tibble::tribble(\n      ~person, ~allies,\n       \"Shiv\",   \"Tom\",\n    \"Kendall\",  \"Greg\",\n      \"Roman\",  \"Geri\"\n    )\n\ncross_join(characters, alliances)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 15 × 4\n   person.x title        person.y allies\n   <chr>    <chr>        <chr>    <chr> \n 1 Shiv     President    Shiv     Tom   \n 2 Shiv     President    Kendall  Greg  \n 3 Shiv     President    Roman    Geri  \n 4 Kendall  Interim CEO  Shiv     Tom   \n 5 Kendall  Interim CEO  Kendall  Greg  \n 6 Kendall  Interim CEO  Roman    Geri  \n 7 Logan    CEO          Shiv     Tom   \n 8 Logan    CEO          Kendall  Greg  \n 9 Logan    CEO          Roman    Geri  \n10 Tom      Head of News Shiv     Tom   \n11 Tom      Head of News Kendall  Greg  \n12 Tom      Head of News Roman    Geri  \n13 Roman    COO          Shiv     Tom   \n14 Roman    COO          Kendall  Greg  \n15 Roman    COO          Roman    Geri  \n```\n:::\n:::\n\n\n\n::: {.callout-tip}\n`cross_join()` achieves the same effect as `tidyr::crossing()` but dplyr is always about data frames whereas `tidyr::crossing()` is more for individual data.\n:::\n\n## Learn more\n\n-   [tidyverse blog: dplyr 1.1.0: `pick()`, `reframe()`, and `arrange()`](https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-pick-reframe-arrange/#arrange)\n-   [dplyr release notes](https://dplyr.tidyverse.org/news/index.html)\n-   [New features in dplyr 1.1.0, and an introduction to ivs](https://www.youtube.com/watch?v=9LAML4Nr1II)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}