{
  "hash": "1f094ed6ab17f09563f1f4097fa96644",
  "result": {
    "markdown": "---\ntitle: \"`case_when()`, `case_match()`, and `consecutive_id()`\"\nsubtitle: \"dplyr 1.1.0\"\ndate: 2023-01-29\nimage: \"dplyr-case-when-case-match-consecutive-id.png\"\nimage-alt: \"Text that says dplyr `case_when()`, `case_match()`, and `consecutive_id()` An screenshot of a command running the new join by helper.\"\ncategories:\n   - \"dplyr\"\ndescription: \"dplyr 1.1.0 has relaxed assumptions for non-equi joins.\"\n---\n\n\nInstall dplyr 1.1.0 with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pak(\"cran/dplyr@1.1.0\")\n```\n:::\n\n\nLoad the package with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\n## case_when()\n\n`case_when()` is a general vectorised if-else.\n\n### `NA`\n\nHave you ever run `case_when()` and gotten the error message:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 12, -5, 6, -2, NA, 0)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_when(\n  x >= 10 ~ \"large\",\n  x >= 0 ~ \"small\",\n  x < 0 ~ NA\n)\n```\n:::\n\n\n```         \nError: `NA` must be <character>, not <logical>.\n```\n\nIn this case, you have to use `NA_character_` instead of `NA`.\n\nBut not anymore!\n\nIn dplyr 1.1.0, the switch to vctrs means that the above code now \"just works\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_when(\n  x >= 10 ~ \"large\",\n  x >= 0 ~ \"small\",\n  x < 0 ~ NA\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"small\" \"large\" NA      \"small\" NA      NA      \"small\"\n```\n:::\n:::\n\n\n### `TRUE`\n\nTo set a default in `case_when()`, you used to have to do this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_when(\n  x >= 10 ~ \"large\",\n  x >= 0 ~ \"small\",\n  is.na(x) ~ \"missing\",\n  TRUE ~ \"other\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"small\"   \"large\"   \"other\"   \"small\"   \"other\"   \"missing\" \"small\"  \n```\n:::\n:::\n\n\nNow there's an explicit argument `.default`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_when(\n  x >= 10 ~ \"large\",\n  x >= 0 ~ \"small\",\n  is.na(x) ~ \"missing\",\n  .default = \"other\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"small\"   \"large\"   \"other\"   \"small\"   \"other\"   \"missing\" \"small\"  \n```\n:::\n:::\n\n\n`TRUE` isn't deprecated yet but the team is planning on deprecating it in the future.\n\n## `case_match()`\n\nSometimes, `case_when()` can be a bit repetitive:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"USA\", \"Canada\", \"Wales\", \"UK\", \"China\", NA, \"Mexico\", \"Russia\")\n\ncase_when(\n  x %in% c(\"USA\", \"Canada\", \"Mexico\") ~ \"North America\",\n  x %in% c(\"Wales\", \"UK\") ~ \"Europe\",\n  x %in% \"China\" ~ \"Asia\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"North America\" \"North America\" \"Europe\"        \"Europe\"       \n[5] \"Asia\"          NA              \"North America\" NA             \n```\n:::\n:::\n\n\n`case_match()` is a special case that matches values and a nice way to do replacements. You can streamline your code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_match(\n  x,\n  c(\"USA\", \"Canada\", \"Mexico\") ~ \"North America\",\n  c(\"France\", \"UK\") ~ \"Europe\",\n  \"China\" ~ \"Asia\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"North America\" \"North America\" NA              \"Europe\"       \n[5] \"Asia\"          NA              \"North America\" NA             \n```\n:::\n:::\n\n\nThey are no longer logical vectors, just values. You can also put `NA` on the left-hand side:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_match(\n  x,\n  c(\"USA\", \"Canada\", \"Mexico\") ~ \"North America\",\n  c(\"France\", \"UK\") ~ \"Europe\",\n  \"China\" ~ \"Asia\",\n  NA ~ \"missing\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"North America\" \"North America\" NA              \"Europe\"       \n[5] \"Asia\"          \"missing\"       \"North America\" NA             \n```\n:::\n:::\n\n\nIt also works with `.default`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_match(\n  x,\n  c(\"USA\", \"Canada\", \"Mexico\") ~ \"North America\",\n  c(\"France\", \"UK\") ~ \"Europe\",\n  \"China\" ~ \"Asia\",\n  NA ~ \"missing\",\n  .default = \"unknown\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"North America\" \"North America\" \"unknown\"       \"Europe\"       \n[5] \"Asia\"          \"missing\"       \"North America\" \"unknown\"      \n```\n:::\n:::\n\n\n::: callout-note\n`if_else()` has received the same updates as `case_when()`. In particular, it is no longer as strict about typed missing values.\n:::\n\n## consecutive_id()\n\n\n\n## Learn more\n\n-   [tidyverse blog: dplyr 1.1.0: `pick()`, `reframe()`, and `arrange()`](https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-pick-reframe-arrange/#arrange)\n-   [dplyr release notes](https://dplyr.tidyverse.org/news/index.html)\n-   [New features in dplyr 1.1.0, and an introduction to ivs](https://www.youtube.com/watch?v=9LAML4Nr1II)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}