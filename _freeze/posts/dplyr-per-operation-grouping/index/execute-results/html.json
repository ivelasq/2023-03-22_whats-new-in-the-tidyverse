{
  "hash": "f64e45a310b3e680c8247d15043ce989",
  "result": {
    "markdown": "---\ntitle: \"Per-operation grouping\"\nsubtitle: \"dplyr 1.1.0\"\nimage: \"per-operation.png\"\nimage-alt: \"Text: Per-operation grouping, dplyr. An image of an example call using by.\"\ncategories:\n  - dplyr\ndate: 2023-01-29\ndescription: \"Introducing by/.by, an experimental grouping alternative to group_by().\"\nengine: knitr\neditor: visual\n---\n\n\nInstall dplyr 1.1.0 with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pak(\"cran/dplyr@1.1.0\")\n```\n:::\n\n\nLoad the package with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\n## Per-operation grouping\n\n`by`/`.by` is an experimental grouping alternative to `group_by()`.\n\n### `group_by()`\n\n`group_by()` provides persistent grouping (lasts for more than one operation) for data operations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions <-\n  tibble::tribble(\n    ~company, ~year, ~revenue,\n         \"A\", 2019L,      20L,\n         \"A\", 2019L,      50L,\n         \"A\", 2020L,       4L,\n         \"B\", 2021L,      10L,\n         \"B\", 2023L,      12L,\n         \"B\", 2023L,      18L\n    )\n```\n:::\n\n\nLet's say you want revenue by company and year:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |>\n  group_by(company, year) |>\n  mutate(total = sum(revenue))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n# Groups:   company, year [4]\n  company  year revenue total\n  <chr>   <int>   <int> <int>\n1 A        2019      20    70\n2 A        2019      50    70\n3 A        2020       4     4\n4 B        2021      10    10\n5 B        2023      12    30\n6 B        2023      18    30\n```\n:::\n:::\n\n\nNotice the message that says `Groups: company, year [4]`.\n\nIf you want only the total yearly revenue of each company, you can use `summarize()` which peels off a layer of grouping by default:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  group_by(company, year) %>% \n  summarize(revenue = sum(revenue))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n# Groups:   company [2]\n  company  year revenue\n  <chr>   <int>   <int>\n1 A        2019      70\n2 A        2020       4\n3 B        2021      10\n4 B        2023      30\n```\n:::\n:::\n\n\n(Year is removed as a group).\n\nWhat if you didn't want groups anymore?\n\n::: panel\n## Before: `ungroup()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  group_by(company, year,) %>% \n  summarize(revenue = sum(revenue)) %>% \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'company'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  company  year revenue\n  <chr>   <int>   <int>\n1 A        2019      70\n2 A        2020       4\n3 B        2021      10\n4 B        2023      30\n```\n:::\n:::\n\n\n## Before: `.groups = \"drop\"`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  group_by(company, year,) %>% \n  summarize(revenue = sum(revenue),\n            .groups = \"drop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  company  year revenue\n  <chr>   <int>   <int>\n1 A        2019      70\n2 A        2020       4\n3 B        2021      10\n4 B        2023      30\n```\n:::\n:::\n\n\n## Now: `by/.by`\n\n`by/.by` introduces the idea of per-operation grouping:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |>\n  mutate(total = sum(revenue), .by = c(company, year))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  company  year revenue total\n  <chr>   <int>   <int> <int>\n1 A        2019      20    70\n2 A        2019      50    70\n3 A        2020       4     4\n4 B        2021      10    10\n5 B        2023      12    30\n6 B        2023      18    30\n```\n:::\n:::\n\n:::\n\nAdvantages:\n\n-   You never have to remember to `ungroup()`.\n-   You can use tidyselect for multiple columns, including unquoted column names or tidyselections like `.by = all_of(c(\"\"))`.\n-   `summarise()` didn't emit a message about regrouping.\n-   Order doesn't matter (because you're not peeling off layers).\n-   You can place the grouping specification alongside the code that uses it, rather than in a separate group_by() line.\n\nThings to note:\n\n-   `by/.by` is only for selection, it does not create columns.\n-   `by/.by` always returns an ungrouped data frame (so take note if you depend on grouped data frames with `group_by()`).\n-   With `by/.by`, you must create your grouping columns ahead of time.\n-   `.by` doesn't sort grouping keys. `group_by()` always sorts keys in ascending order, which affects the results of verbs like `summarize()`.\n\n## Where did this come from?\n\n`by/.by` was inspired by data.table!\n\n-   `by` is specified alongside what you want to group &\n-   You start with a bare data table and then do this and end up with a bare data table, rather than having a grouped data frame like in dplyr.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions[, .(revenue = sum(revenue)), by = .(company, year)]\n```\n:::\n\n\nThis raised the question, what if you can put it in line with your summarize call?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  summarize(\n    revenue = sum(revenue), \n    by = c(company, year)\n    )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 2\n   revenue by   \n     <int> <chr>\n 1     114 A    \n 2     114 A    \n 3     114 A    \n 4     114 B    \n 5     114 B    \n 6     114 B    \n 7     114 2019 \n 8     114 2019 \n 9     114 2020 \n10     114 2021 \n11     114 2023 \n12     114 2023 \n```\n:::\n:::\n\n\nNotice this is longer grouped by company on the way out. It does the **one operation** then drops off.\n\n## In summary\n\n1.  `by/.by` is per-operation grouping\n2.  `group_by()` is persistent grouping\n\n::: panel-tabset\n## Before\n\n\n```{mermaid}\nflowchart LR\n  A[Bare tibble] --> B(Transaction)\n  B --> C{Grouped data frame}\n```\n\n\n## After\n\n\n```{mermaid}\nflowchart LR\n  A[Bare tibble] --> B(Transaction)\n  B --> C[Bare tibble]\n```\n\n:::\n\n### dplyr verbs that support `by/.by`:\n\n-   `mutate()`\n-   `summarize()`\n-   `reframe()`\n-   `filter()`\n-   `slice()`\n-   `slide_head()` and `slice_tail()`\n-   `slide_min()` and `slice_max()`\n-   `slice_sample()`\n\n### `by` or `.by`?\n\nSome verbs use `.` prefix for their arguments and some don't. If you use the incorrect one, you will get an informative error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions |>\n  slice_max(revenue, n = 2, .by = company)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `slice_max()`:\n! Can't specify an argument named `.by` in this verb.\nℹ Did you mean to use `by` instead?\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  slice_max(revenue, n = 2, by = company)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  company  year revenue\n  <chr>   <int>   <int>\n1 A        2019      50\n2 A        2019      20\n3 B        2023      18\n4 B        2023      12\n```\n:::\n:::\n\n\n## What happens to group_by?\n\nIt's not going away! It is not deprecated or even superseded. Don't feel pressure to use `by/.by`.\n\n### Learn more\n\n-   [tidyverse blog: dplyr 1.1.0: Per-operation grouping](https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-per-operation-grouping/)\n-   [New features in dplyr 1.1.0, and an introduction to ivs](https://www.youtube.com/watch?v=9LAML4Nr1II&t=111s)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}