{
  "hash": "d6c1499217dd7a4fee6f23b45d0c430e",
  "result": {
    "markdown": "---\ntitle: \"Per-operation grouping\"\nsubtitle: \"dplyr\"\ncategories:\n  - dplyr\nimage: \"per-operation.png\"\nimage-alt: \"Text: Per-operation grouping, dplyr. An image of an example call using by.\"\ndate: 2023-02-01\n---\n\n\nInstall the latest version of dplyr with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"dplyr\")\n```\n:::\n\n\nLoad dplyr with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ntransactions <-\n  tibble::tribble(\n    ~company, ~year, ~revenue,\n         \"A\", 2019L,      20L,\n         \"A\", 2019L,      50L,\n         \"A\", 2020L,       4L,\n         \"B\", 2021L,      10L,\n         \"B\", 2023L,      12L,\n         \"B\", 2023L,      18L\n    )\n```\n:::\n\n\n\nTotal yearly revenue of each company?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  group_by(company, year) %>% \n  summarize(revenue = sum(revenue))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n# Groups:   company [2]\n  company  year revenue\n  <chr>   <int>   <int>\n1 A        2019      70\n2 A        2020       4\n3 B        2021      10\n4 B        2023      30\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  group_by(company, year,) %>% \n  summarize(revenue = sum(revenue)) %>% \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  company  year revenue\n  <chr>   <int>   <int>\n1 A        2019      70\n2 A        2020       4\n3 B        2021      10\n4 B        2023      30\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  group_by(company, year,) %>% \n  summarize(revenue = sum(revenue),\n            .groups = \"drop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  company  year revenue\n  <chr>   <int>   <int>\n1 A        2019      70\n2 A        2020       4\n3 B        2021      10\n4 B        2023      30\n```\n:::\n:::\n\n\nEnter... datatable\n\nexplain datatable\nby is specified alongside what you want to group\nyou start with a bare data table and then do this and end up with a bare data table, rather than having a grouped data frame like in dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions[, .(revenue = sum(revenue)), by = .(company, year)]\n```\n:::\n\n\nwhat if you can put it in line with your summarize call?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  summarize(\n    revenue = sum(revenue), \n    by = c(company, year)\n    )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 2\n   revenue by   \n     <int> <chr>\n 1     114 A    \n 2     114 A    \n 3     114 A    \n 4     114 B    \n 5     114 B    \n 6     114 B    \n 7     114 2019 \n 8     114 2019 \n 9     114 2020 \n10     114 2021 \n11     114 2023 \n12     114 2023 \n```\n:::\n:::\n\nno longer grouped by company on the way out\n\n1. .by is per-operation grouping\n2. group_by is persistent grouping\n\nbythe one operation (summarize) then drop off\nbare tibble -> transaction -> always get a bare tibble not a grouped data frame\ndon't have to remember ungroup or specify groups = drop\n\n- show lines with more calls (mutate)\n\nuse tidyselect unquoted column names inside `c()` or starts-with\n.by = all_of(c(\"\"))\nby is just selection, does not create columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransactions %>% \n  slice_max(revenue, n = 2, by = company)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  company  year revenue\n  <chr>   <int>   <int>\n1 A        2019      50\n2 A        2019      20\n3 B        2023      18\n4 B        2023      12\n```\n:::\n:::\n\n\nmutate\nsummarize\nfilter\nslice_*\n\nwhat happens to group_by?\n\nit's not going away? not depricated or even superceded (discovered something better)\n\nyou don't have to remember what will be taken off (outer most) and the order doesnt' matter\nbe more explict \n\nLearn more\n\n* https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-per-operation-grouping/\n* [New features in dplyr 1.1.0, and an introduction to ivs](https://www.youtube.com/watch?v=9LAML4Nr1II&t=111s)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}