{
  "hash": "61fd485d00f7dedf0d2ac6795bb5bf01",
  "result": {
    "markdown": "---\ntitle: \"New str_* functions\"\nsubtitle: \"stringr 1.5.0\"\ndate: 2022-12-02\ncategories:\n  - stringr\nimage: \"stringr-new-str-funs.png\"\nimage-alt: \"Text: New str_* functions stringr. Image of various new stringr functions.\"\ndescription: \"stringr has accumulated several new functions since its last release three years ago.\"\n---\n\n\nInstall stringr 1.5.0 with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pak(\"cran/stringr@1.5.0\")\n```\n:::\n\n\nLoad the package with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n```\n:::\n\n\n## New str_* functions\n\n* [str_view()](#str_view)\n* [str_equal()](#str_equal)\n* [str_rank()](#str_rank)\n* [str_unique()](#str_unique)\n* [str_split_1()](#str_split_1)\n* [str_split_i()](str_split_i)\n* [str_escape()](str_escape) \n\n### str_view()\n\n`str_view()` lets you clearly see a string with special characters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"a\\n'\\b\\n\\\"c\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\\n'\\b\\n\\\"c\"\n```\n:::\n:::\n\n\n::: {.panel-tabset}\n\n## Base R\n\nIn base R, you can use `writeLines()` to get a good look at the string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteLines(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\n'\b\n\"c\n```\n:::\n:::\n\n\n## stringr\nNow you can use `str_view()`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ a\n    │ '\b\n    │ \"c\n```\n:::\n:::\n\n\n:::\n\n`str_view()` also highlights strings with special characters:\n\n::: {.panel-tabset}\n\n## White space\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnbsp <- \"Hi\\u00A0you\"\nnbsp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hi you\"\n```\n:::\n\n```{.r .cell-code}\nnbsp == \"Hi you\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nstr_view(nbsp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Hi{\\u00a0}you\n```\n:::\n:::\n\n\n## Tabs\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab_space <- \"\\t\"\nstr_view(tab_space)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ {\\t}\n```\n:::\n:::\n\n\n:::\n\nFinally, `str_view()` makes matches stand out:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(c(\"abc\", \"def\", \"fghi\"), \"[aeiou]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <a>bc\n[2] │ d<e>f\n[3] │ fgh<i>\n```\n:::\n\n```{.r .cell-code}\nstr_view(c(\"abc\", \"def\", \"fghi\"), \".$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ ab<c>\n[2] │ de<f>\n[3] │ fgh<i>\n```\n:::\n\n```{.r .cell-code}\nstr_view(fruit, \"(.)\\\\1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] │ a<pp>le\n [5] │ be<ll> pe<pp>er\n [6] │ bilbe<rr>y\n [7] │ blackbe<rr>y\n [8] │ blackcu<rr>ant\n [9] │ bl<oo>d orange\n[10] │ bluebe<rr>y\n[11] │ boysenbe<rr>y\n[16] │ che<rr>y\n[17] │ chili pe<pp>er\n[19] │ cloudbe<rr>y\n[21] │ cranbe<rr>y\n[23] │ cu<rr>ant\n[28] │ e<gg>plant\n[29] │ elderbe<rr>y\n[32] │ goji be<rr>y\n[33] │ g<oo>sebe<rr>y\n[38] │ hucklebe<rr>y\n[47] │ lych<ee>\n[50] │ mulbe<rr>y\n... and 9 more\n```\n:::\n:::\n\n\n### str_equal()\n\nUse `str_equal()` to determine if two strings are equivalent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_equal(\"a\", \"A\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nYou have the option to ignore case:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_equal(\"a\", \"A\", ignore_case = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\na1 <- \"\\u00e1\"\na2 <- \"a\\u0301\"\nc(a1, a2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"á\" \"á\"\n```\n:::\n\n```{.r .cell-code}\na1 == a2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nstr_equal(a1, a2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### str_rank()\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_rank(c(\"a\", \"c\", \"b\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 2 2\n```\n:::\n\n```{.r .cell-code}\nstr_order(c(\"a\", \"c\", \"b\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 4 2\n```\n:::\n:::\n\n\n### str_unique()\n\n`str_unique()` returns unique values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_unique(c(\"a\", \"a\", \"A\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"A\"\n```\n:::\n:::\n\n\nYou have the option to ignore case:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_unique(c(\"a\", \"a\", \"A\"), ignore_case = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n:::\n\n\n### str_split_1() \n\n`str_split_1()` splits a single string. It returns a character vector, not a list:\n\n::: {.panel-tabset}\n\n## Before 1.5.0\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(str_split(\"x-y-z\", \"-\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x\" \"y\" \"z\"\n```\n:::\n:::\n\n\n## After 1.5.0\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_split_1(\"x-y-z\", \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x\" \"y\" \"z\"\n```\n:::\n:::\n\n\n:::\n\n`str_split_1()` errors if you try and give it multiple values:\n\n### str_split_i()\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a-b-c\", \"d-e\", \"f-g-h-i\")\nstr_split_i(x, \"-\", 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"b\" \"e\" \"g\"\n```\n:::\n\n```{.r .cell-code}\nstr_split_i(x, \"-\", 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA  NA  \"i\"\n```\n:::\n\n```{.r .cell-code}\nstr_split_i(x, \"-\", -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"c\" \"e\" \"i\"\n```\n:::\n:::\n\n\n`str_like()` works like `str_detect()` but uses SQL’s LIKE syntax:\n \n\n::: {.cell}\n\n```{.r .cell-code}\nfruit <- c(\"apple\", \"banana\", \"pear\", \"pineapple\")\nfruit[str_like(fruit, \"%apple\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"apple\"     \"pineapple\"\n```\n:::\n\n```{.r .cell-code}\nfruit[str_like(fruit, \"p__r\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pear\"\n```\n:::\n:::\n\n\n### Learn more\n\n* [tidyverse blog: stringr 1.5.0](https://www.tidyverse.org/blog/2022/12/stringr-1-5-0/)\n* [stringr release notes](https://stringr.tidyverse.org/news/index.html)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}