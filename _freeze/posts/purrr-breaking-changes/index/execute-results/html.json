{
  "hash": "a28f926b39d867850dcdb14a008b22df",
  "result": {
    "markdown": "---\ntitle: \"Breaking changes\"\nsubtitle: \"purrr 1.1.0\"\ndate: 2022-12-20\nimage: \"purrr-breaking-changes.png\"\nimage-alt: \"purrr 1.1.0 breaking changes. Screenshot of text of various separate functions.\"\ncategories:\n  - \"purrr\"\ndescription: A new family of `separate_*()` functions supersedes `separate()`, `separate_rows()`, and `extract()`.\nengine: knitr\neditor: visual\n---\n\n\nInstall purrr 1.0.0 with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pak(\"cran/purrr@1.0.0\")\n```\n:::\n\n\nLoad the package with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n:::\n\n\n## Breaking changes\n\nThere are four important changes in purrr 1.0.0:\n\n-   `pluck()` behaves differently when extracting 0-length vectors.\n-   The `map()` family uses the tidyverse rules for coercion and recycling.\n-   All functions that modify lists handle `NULL` consistently.\n-   Deprecated functions that aren't related to the core purpose of purrr.\n\n### `pluck()` and zero-length vectors\n\n`pluck()` is a function that lets you safely get or set an element within a nested structure.\n\nBefore, `pluck()` replaced 0-length vectors with the value of default. Now default is only used for `NULL` and absent elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n\nx <- list(y = list(a = character(), b = NULL))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$y\n$y$a\ncharacter(0)\n\n$y$b\nNULL\n```\n:::\n:::\n\n\n::: panel-tabset\n## Before\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr, lib.loc = new_lib)\nx |> pluck(\"y\", \"a\", .default = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncharacter(0)\n```\n:::\n:::\n\n\n\n\n## After\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nx |> pluck(\"y\", \"a\", .default = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncharacter(0)\n```\n:::\n:::\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> pluck(\"y\", \"b\", .default = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> pluck(\"y\", \"c\", .default = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nThis also impacts `map_*` because using an integer vector, character vector, or list instead of a function automatically calls `pluck()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(list(1), list(), list(NULL), list(character()))\nx |> map(1, .default = 0) |> str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ : num 1\n $ : num 0\n $ : num 0\n $ : chr(0) \n```\n:::\n:::\n\n\n## Tidyverse consistency\n\nThe team edited the `map_*` family to be consistent with general tidyverse coercion and recycling rules, as implemented by the vctrs package.\n\n-   `map_lgl()`\n-   `map_int()`\n-   `map_int()`\n-   `map_dbl()`\n\n::: panel-tabset\n## Before\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_chr(1:4, \\(x) x + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2.000000\" \"3.000000\" \"4.000000\" \"5.000000\"\n```\n:::\n:::\n\n\n## After\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_chr(1:4, \\(x) as.character(x + 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2\" \"3\" \"4\" \"5\"\n```\n:::\n:::\n\n:::\n\nGeneral principles:\n\n-   Converting a logical/integer/double to a character vector is potentially dangerous and should require an explicit coercion.\n-   Vectors of length 1 are recycled to any size but all other vectors must have the same length.\n\n## Assigning `NULL`\n\npurrr has a number of functions that modify a list:\n\n-   `pluck()`\n-   `assign_in()`\n-   `modify()`\n-   `modify2()`\n-   `modify_if()`\n-   `modify_at()`\n-   `list_modify()`\n\nPreviously, these functions had inconsistent behavior when you attempted to modify an element with `NULL`: some functions would delete that element, and some would set it to NULL.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- x2 <- x3 <- list(a = 1, b = 2)\n\nx1$a <- NULL\nstr(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ b: num 2\n```\n:::\n\n```{.r .cell-code}\nx2[\"a\"] <- list(NULL)\nstr(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ a: NULL\n $ b: num 2\n```\n:::\n:::\n\n\nNow functions that edit a list will create an element containing `NULL`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx3 |> \n  list_modify(a = NULL) |> \n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ a: NULL\n $ b: num 2\n```\n:::\n\n```{.r .cell-code}\nx3 |> \n  modify_at(\"b\", \\(x) NULL) |> \n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ a: num 1\n $ b: NULL\n```\n:::\n:::\n\n\nIf you want to delete the element, you can use `zap()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx3 |> \n  list_modify(a = zap()) |> \n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ b: num 2\n```\n:::\n:::\n\n\n### Deprecations\n\n#### `cross()` and `cross_df()`\n\n`cross()`and all its variants have been deprecated in favor of `tidyr::expand_grid()`. These functions were slow and buggy:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk = 12\nx = rep(list(1:3), k) |>\n  setNames(LETTERS[1:k])\n\nsystem.time({ x |> purrr::cross_df() })\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n 28.826   0.745 115.900 \n```\n:::\n\n```{.r .cell-code}\nsystem.time({ x |> tidyr::expand_grid() })\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.113   0.012   0.303 \n```\n:::\n:::\n\n\n#### `update_list()`, `rerun()`, and the use of tidyselect with `map_at()`\n\n`update_list()`, `rerun()`, and the use of tidyselect with `map_at()` and friends have been deprecated because non-standard evaluation is not a good fit for purrr.\n\n[In most programming languages, you can only access the values of a function's arguments. In R, you can also access the code used to compute them. This makes it possible to evaluate code in non-standard ways: to use what is known as non-standard evaluation, or NSE for short.]{.aside}[^1]\n\n[^1]: [https://adv-r.hadley.nz/metaprogramming.html]{.aside}\n\n#### `lift_*`\n\nThe `lift_*` family of functions has been superceded because they promote a style of function manipulation that is not commonly used in R.\n\n#### `prepend()`, `rdunif()`, `rbernoulli()`, `when()`, and `list_along()`\n\nThese have been deprecated because they're not directly related to functional programming.\n\n#### splice()\n\n`splice()` has been deprecated because automatic splicing doesn't make for good UI and there are other ways to achieve the same result.\n\n### Learn more\n\n-   [tidyverse blog: purrr 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/)\n-   [purrr release notes](https://github.com/tidyverse/purrr/releases/tag/v1.0.0)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}