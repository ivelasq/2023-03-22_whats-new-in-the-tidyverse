{
  "hash": "e704aadf09cce4c017ccab3baee798b7",
  "result": {
    "markdown": "---\ntitle: \"pick(), reframe(), and arrange()\"\nsubtitle: \"dplyr 1.1.0\"\ndate: 2023-01-29\nimage: \"dplyr-pick-reframe-arrange.png\"\nimage-alt: \"dplyr 1.1.0. Image of two benchmark comparisons arranging a vector in the old and new dplyr.\"\ncategories:\n  - dplyr\ndescription: \"dplyr 1.1.0 is waaaay faster at sorting character vectors, and introduces `pick()` and `reframe()` as better alternatives for your data workflow.\"\nengine: knitr\neditor: visual\n---\n\n\nInstall dplyr 1.1.0 with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pak(\"cran/dplyr@1.1.0\")\n```\n:::\n\n\nLoad the package with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n\n## pick()\n\nYou may have used `across()` for column selection while working inside a data-masking function like `mutate()` or `summarize()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  x_1 = c(1, 3, 2, 1, 2), \n  x_2 = 6:10, \n  w_4 = 11:15, \n  y_2 = c(5, 2, 4, 0, 6)\n)\n\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n    x_1   x_2   w_4   y_2\n  <dbl> <int> <int> <dbl>\n1     1     6    11     5\n2     3     7    12     2\n3     2     8    13     4\n4     1     9    14     0\n5     2    10    15     6\n```\n:::\n\n```{.r .cell-code}\ndf |>\n  summarise(\n    n_x = ncol(across(starts_with(\"x\"))),\n    n_y = ncol(across(starts_with(\"y\")))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n    n_x   n_y\n  <int> <int>\n1     2     1\n```\n:::\n:::\n\n\nBut, `across()` is meant to apply functions to columns, not select them. dplyr 1.1.0 provides a new function for this function :), called `pick()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  summarise(\n    n_x = ncol(pick(starts_with(\"x\"))),\n    n_y = ncol(pick(starts_with(\"y\")))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n    n_x   n_y\n  <int> <int>\n1     2     1\n```\n:::\n:::\n\n\n`across()` still works without functions for now, but the tidyverse team plans to deprecate it in the future.\n\n## reframe()\n\ndplyr 1.0.0 introduces a powerful new feature: `summarise()` could return per-group results of any length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable <- c(\"a\", \"b\", \"d\", \"f\")\n\ndf <- tibble(\n  g = c(1, 1, 1, 2, 2, 2, 2),\n  x = c(\"e\", \"a\", \"b\", \"c\", \"f\", \"d\", \"a\")\n)\n\ndf |>\n  summarise(x = intersect(x, table), .by = g)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n      g x    \n  <dbl> <chr>\n1     1 a    \n2     1 b    \n3     2 f    \n4     2 d    \n5     2 a    \n```\n:::\n:::\n\n\nHowever, this raised some concerns.\n\n-   Increases the chance for accidental bugs\n-   Is against the spirit of a \"summary,\" which implies 1 row per group\n-   Makes translation to dbplyr very difficult\n\nThis feature has been walked back and summarize will throw a warning when either 0 or \\>1 rows are returned per group.\n\nAs its replacement, welcome new function `reframe()`!\n\nThink of `reframe()` as: \"do something to each group\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  reframe(x = intersect(x, table), .by = g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n      g x    \n  <dbl> <chr>\n1     1 a    \n2     1 b    \n3     2 f    \n4     2 d    \n5     2 a    \n```\n:::\n:::\n\n\n`reframe()` always returns an ungrouped data frame (i.e., not a grouped data frame even if the input was grouped).\n\n## arrange()\n\nWhen sorting character vectors, the C locale is now the default, rather than the system locale. This makes dplyr wayyy faster at sorting character variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(withr)\nlibrary(dplyr)\n\ndf <- tibble(x = stringi::stri_rand_strings(n = 5e5, length = 15))\n\nwithr::with_options(list(dplyr.legacy_locale = TRUE),\n                    {\n                      bench::system_time(df %>% arrange(x))\n                    })\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nprocess    real \n  4.59s   4.95s \n```\n:::\n\n```{.r .cell-code}\nbench::system_time(df %>% arrange(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nprocess    real \n  332ms   356ms \n```\n:::\n:::\n\n\nThere is a new `.locale` argument for you to explicitly request an alternative locale using a stringi locale identifier (like \"en\" for English, or \"fr\" for French).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::system_time(df %>% arrange(x, locale = \"fr\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nprocess    real \n  385ms   427ms \n```\n:::\n:::\n\n\n## Learn more\n\n-   [tidyverse blog: dplyr 1.1.0: `pick()`, `reframe()`, and `arrange()`](https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-pick-reframe-arrange/#arrange)\n-   [dplyr release notes](https://dplyr.tidyverse.org/news/index.html)\n-   [New features in dplyr 1.1.0, and an introduction to ivs](https://www.youtube.com/watch?v=9LAML4Nr1II&t=1252s)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}