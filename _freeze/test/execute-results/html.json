{
  "hash": "ba07cdbf118a6396993bef5bfb501610",
  "result": {
    "markdown": "---\ntitle: \"Untitled\"\n---\n---\ntitle: \"Breaking changes\"\nsubtitle: \"purrr 1.1.0\"\ndate: 2022-12-20\nimage: \"purrr-breaking-changes.png\"\nimage-alt: \"purrr 1.1.0 breaking changes. Screenshot of text of various separate functions.\"\ncategories:\n  - \"purrr\"\ndescription: A new family of `separate_*()` functions supersedes `separate()`, `separate_rows()`, and `extract()`.\nengine: knitr\neditor: source\n---\n\nInstall purrr 1.0.0 with:\n\n::: {.cell}\n\n```{.r .cell-code}\npak::pak(\"cran/purrr@1.0.0\")\n```\n:::\n\nLoad the package with:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n:::\n\n## Breaking changes\n\nThere are four important changes in purrr 1.0.0:\n\n* `pluck()` behaves differently when extracting 0-length vectors.\n* The `map()` family uses the tidyverse rules for coercion and recycling.\n* All functions that modify lists handle `NULL` consistently.\n* We've deprecated functions that aren't related to the core purpose of purrr.\n\n### `pluck()` and zero-length vectors\n\nPreviously, `pluck()` replaced 0-length vectors with the value of default. Now default is only used for `NULL` and absent elements:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n\nx <- list(y = list(a = character(), b = NULL))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$y\n$y$a\ncharacter(0)\n\n$y$b\nNULL\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx %>% pluck(\"y\", \"a\", .default = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncharacter(0)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> pluck(\"y\", \"b\", .default = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> pluck(\"y\", \"c\", .default = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\nThis also impacts `map_*`:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(list(1), list(), list(NULL), list(character()))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[[1]][[1]]\n[1] 1\n\n\n[[2]]\nlist()\n\n[[3]]\n[[3]][[1]]\nNULL\n\n\n[[4]]\n[[4]][[1]]\ncharacter(0)\n```\n:::\n\n```{.r .cell-code}\nx %>% map(1, .default = 0) %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ : num 1\n $ : num 0\n $ : num 0\n $ : chr(0) \n```\n:::\n:::\n\npurrr has a number of functions that modify a list: `pluck()`, `assign_in()`, `modify()`, `modify2()`, `modify_if()`, `modify_at()`, and `list_modify()`. \n\nPreviously, these functions had inconsistent behavior when you attempted to modify an element with `NULL`: some functions would delete that element, and some would set it to NULL.\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- x2 <- x3 <- list(a = 1, b = 2)\n\nx1$a <- NULL\nstr(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ b: num 2\n```\n:::\n\n```{.r .cell-code}\nx2[\"a\"] <- list(NULL)\nstr(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ a: NULL\n $ b: num 2\n```\n:::\n:::\n\nNow functions that edit a list will create an element containing `NULL`:\n\n::: {.cell}\n\n```{.r .cell-code}\nx3 |> \n  list_modify(a = NULL) |> \n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ a: NULL\n $ b: num 2\n```\n:::\n\n```{.r .cell-code}\nx3 |> \n  modify_at(\"b\", \\(x) NULL) |> \n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ a: num 1\n $ b: NULL\n```\n:::\n\n```{.r .cell-code}\nx3 |> \n  list_modify(a = zap()) |> \n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ b: num 2\n```\n:::\n:::\n\n### Deprecations\n\n#### `cross()` and `cross_df()`\n\n`cross() `and all its variants have been deprecated in favor of `tidyr::expand_grid()`. These functions were slow and buggy:\n\n::: {.cell}\n\n```{.r .cell-code}\nk = 12\nx = rep(list(1:3), k) %>%\n  setNames(LETTERS[1:k])\n\nsystem.time({ x %>% purrr::cross_df() })\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n 30.736   0.929  33.789 \n```\n:::\n\n```{.r .cell-code}\nsystem.time({ x %>% tidyr::expand_grid() })\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.139   0.023   0.233 \n```\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}