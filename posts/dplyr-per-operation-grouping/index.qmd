---
title: "Per-operation grouping"
subtitle: "dplyr 1.1.0"
image: "per-operation.png"
image-alt: "Text: Per-operation grouping, dplyr. An image of an example call using by."
categories:
  - dplyr
date: 2023-01-29
description: tidyverse 2.0.0 has been released!
engine: knitr
editor: visual
---

Install dplyr 1.1.0 with:

```{r}
#| eval: false
pak::pak("cran/dplyr@1.1.0")
```

Load the package with:

```{r}
#| message: false
library(dplyr)
```

## Per-operation grouping

`by`/`.by` is an experimental grouping alternative to `group_by()`.

### `group_by()`

`group_by()` provides persistent grouping (lasts for more than one operation) for data operations.

```{r}
transactions <-
  tibble::tribble(
    ~company, ~year, ~revenue,
         "A", 2019L,      20L,
         "A", 2019L,      50L,
         "A", 2020L,       4L,
         "B", 2021L,      10L,
         "B", 2023L,      12L,
         "B", 2023L,      18L
    )
```

Let's say you want revenue by company and year:

```{r}
transactions |>
  group_by(company, year) |>
  mutate(total = sum(revenue))
```

Notice the message that says `Groups: company, year [4]`.

If you want only the total yearly revenue of each company, you can use `summarize()` which peels off a layer of grouping by default:

```{r}
#| message: false
transactions %>% 
  group_by(company, year) %>% 
  summarize(revenue = sum(revenue))
```

(Year is removed as a group).

What if you didn't want groups anymore?

:::{.panel}

## Before: `ungroup()`

```{r}
transactions %>% 
  group_by(company, year,) %>% 
  summarize(revenue = sum(revenue)) %>% 
  ungroup()
```

## Before: `.groups = "drop"`

```{r}
transactions %>% 
  group_by(company, year,) %>% 
  summarize(revenue = sum(revenue),
            .groups = "drop")
```

## Now: `by/.by`

`by/.by` introduces the idea of per-operation grouping:

```{r}
transactions |>
  mutate(total = sum(revenue), .by = c(company, year))
```

:::

Advantages:

* You never have to remember to `ungroup()`.
* You can use tidyselect for multiple columns.
* `summarise()` didnâ€™t emit a message about regrouping.
* You can place the grouping specification alongside the code that uses it, rather than in a separate group_by() line.

`by/.by` was inspired by data.table!

* `by` is specified alongside what you want to group &
* You start with a bare data table and then do this and end up with a bare data table, rather than having a grouped data frame like in dplyr.

```{r}
#| eval: false
transactions[, .(revenue = sum(revenue)), by = .(company, year)]
```

This raised the question, what if you can put it in line with your summarize call?

```{r}
transactions %>% 
  summarize(
    revenue = sum(revenue), 
    by = c(company, year)
    )
```

Notice this is longer grouped by company on the way out. It does the **one operation** then drops off.

1. .by is per-operation grouping
2. group_by is persistent grouping

bythe one operation (summarize) then drop off
bare tibble -> transaction -> always get a bare tibble not a grouped data frame

- show lines with more calls (mutate)

use tidyselect unquoted column names inside `c()` or starts-with
.by = all_of(c(""))
by is just selection, does not create columns

```{r}
transactions %>% 
  slice_max(revenue, n = 2, by = company)
```

mutate
summarize
filter
slice_*

## What happens to group_by?

It's not going away! It is not deprecated or even superseded.

Learn more

* https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-per-operation-grouping/
* [New features in dplyr 1.1.0, and an introduction to ivs](https://www.youtube.com/watch?v=9LAML4Nr1II&t=111s)
