"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Readline = void 0;
const keymap_1 = require("./keymap");
const state_1 = require("./state");
const history_1 = require("./history");
const tty_1 = require("./tty");
const highlight_1 = require("./highlight");
class Readline {
    constructor() {
        this.highlighter = new highlight_1.IdentityHighlighter();
        this.history = new history_1.History(50);
        this.disposables = [];
        this.watermark = 0;
        this.highWatermark = 10000;
        this.lowWatermark = 1000;
        this.highWater = false;
        this.state = new state_1.State(">", this.tty(), this.highlighter, this.history);
        this.checkHandler = () => true;
        this.ctrlCHandler = () => {
            return;
        };
        this.pauseHandler = (resume) => {
            return;
        };
        this.history.restoreFromLocalStorage();
    }
    /**
     * Activate this addon - this function is called by xterm's
     * loadAddon().
     *
     * @param term - The terminal this readline is attached to.
     */
    activate(term) {
        this.term = term;
        this.term.onData(this.readData.bind(this));
        this.term.attachCustomKeyEventHandler(this.handleKeyEvent.bind(this));
    }
    /**
     * Dispose
     *
     */
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
    /**
     * Manually append a line to the top of the readline's history.
     *
     * @param text - The text to append to history.
     */
    appendHistory(text) {
        this.history.append(text);
    }
    /**
     * Set the highlighter handler for this readline. This is used to
     * create custom highlighting functionality (e.g. for syntax highlighting
     * or bracket matching).
     *
     * @param highlighter - A handler to handle all highlight callbacks.
     */
    setHighlighter(highlighter) {
        this.highlighter = highlighter;
    }
    /**
     * Set the check callback. This callback is used by readline to determine if input
     * requires additiona lines when the user presses 'enter'.
     *
     * @param fn - A function (string) -> boolean that should return true if the input
     *             is complete, and false if a line (\n) should be added to the input.
     */
    setCheckHandler(fn) {
        this.checkHandler = fn;
    }
    /**
     * Set the ctrl-c handler. This function will be called if ctrl-c is encountered
     * between readline reads. This may be used in circumstances where input from the
     * user may result in a long running task that can be cancelled.
     *
     * @param fn - The ctrl-c handler.
     */
    setCtrlCHandler(fn) {
        this.ctrlCHandler = fn;
    }
    /**
     * Set the callback to be called when the user presses ctrl-s/ctrl-q.
     *
     * @param fn - The pause handler
     */
    setPauseHandler(fn) {
        this.pauseHandler = fn;
    }
    /**
     * writeReady() may be used to implement basic output flow control. This function
     * will return false if the writes to the terminal initiated by Readline have
     * reached a highwater mark.
     *
     * @returns true if this terminal is accepting more input.
     */
    writeReady() {
        return !this.highWater;
    }
    /**
     * Write text to the terminal.
     *
     * @param text - The text to write to the terminal.
     */
    write(text) {
        if (text === "\n") {
            text = "\r\n";
        }
        else {
            text = text.replace(/^\n/, "\r\n");
            text = text.replace(/([^\r])\n/g, "$1\r\n");
        }
        const outputLength = text.length;
        this.watermark += outputLength;
        if (this.watermark > this.highWatermark) {
            this.highWater = true;
        }
        if (this.term) {
            this.term.write(text, () => {
                this.watermark = Math.max(this.watermark - outputLength, 0);
                if (this.highWater && this.watermark < this.lowWatermark) {
                    this.highWater = false;
                }
            });
        }
    }
    /**
     * Write text to the terminal.
     *
     * @param text - The text to write to the terminal
     */
    print(text) {
        return this.write(text);
    }
    /**
     * Write text to the terminal and append with "\r\n".
     *
     * @param text - The text to write to the terminal./
     * @returns
     */
    println(text) {
        return this.write(text + "\r\n");
    }
    /**
     * Obtain an output interface to this terminal.
     *
     * @returns Output
     */
    output() {
        return this;
    }
    /**
     * Obtain a tty interface to this terminal.
     *
     * @returns A tty
     */
    tty() {
        var _a, _b;
        if (((_b = (_a = this.term) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.tabStopWidth) !== undefined) {
            return new tty_1.Tty(this.term.cols, this.term.rows, this.term.options.tabStopWidth, this.output());
        }
        else {
            return new tty_1.Tty(0, 0, 8, this.output());
        }
    }
    /**
     * Display the given prompt and wait for one line of input from the
     * terminal. The returned promise will be executed when a line has been
     * read from the terminal.
     *
     * @param prompt The prompt to use.
     * @returns A promise to be called when the input has been read.
     */
    read(prompt) {
        return new Promise((resolve, reject) => {
            if (this.term === undefined) {
                reject("addon is not active");
                return;
            }
            this.state = new state_1.State(prompt, this.tty(), this.highlighter, this.history);
            this.state.refresh();
            this.activeRead = { prompt, resolve, reject };
        });
    }
    handleKeyEvent(event) {
        if (event.key === "Enter" && event.shiftKey) {
            if (event.type === "keydown") {
                this.readKey({
                    inputType: keymap_1.InputType.ShiftEnter,
                    data: ["\r"],
                });
            }
            return false;
        }
        return true;
    }
    readData(data) {
        const input = (0, keymap_1.parseInput)(data);
        if (input.length > 1 ||
            (input[0].inputType === keymap_1.InputType.Text && input[0].data.length > 1)) {
            this.readPaste(input);
            return;
        }
        this.readKey(input[0]);
    }
    readPaste(input) {
        const mappedInput = input.map((it) => {
            if (it.inputType === keymap_1.InputType.Enter) {
                return { inputType: keymap_1.InputType.Text, data: ["\n"] };
            }
            return it;
        });
        for (const it of mappedInput) {
            if (it.inputType === keymap_1.InputType.Text) {
                this.state.editInsert(it.data.join(""));
            }
            else {
                this.readKey(it);
            }
        }
    }
    readKey(input) {
        var _a, _b, _c;
        if (this.activeRead === undefined) {
            switch (input.inputType) {
                case keymap_1.InputType.CtrlC:
                    this.ctrlCHandler();
                    break;
                case keymap_1.InputType.CtrlL:
                    this.write("\x1b[H\x1b[2J");
                    break;
            }
            return;
        }
        switch (input.inputType) {
            case keymap_1.InputType.Text:
                this.state.editInsert(input.data.join(""));
                break;
            case keymap_1.InputType.AltEnter:
            case keymap_1.InputType.ShiftEnter:
                this.state.editInsert("\n");
                break;
            case keymap_1.InputType.Enter:
                if (this.checkHandler(this.state.buffer())) {
                    this.state.moveCursorToEnd();
                    (_a = this.term) === null || _a === void 0 ? void 0 : _a.write("\r\n");
                    this.history.append(this.state.buffer());
                    (_b = this.activeRead) === null || _b === void 0 ? void 0 : _b.resolve(this.state.buffer());
                    this.activeRead = undefined;
                }
                else {
                    this.state.editInsert("\n");
                }
                break;
            case keymap_1.InputType.CtrlC:
                this.state.moveCursorToEnd();
                (_c = this.term) === null || _c === void 0 ? void 0 : _c.write("^C\r\n");
                this.state = new state_1.State(this.activeRead.prompt, this.tty(), this.highlighter, this.history);
                this.state.refresh();
                break;
            case keymap_1.InputType.CtrlS:
                this.pauseHandler(false);
                break;
            case keymap_1.InputType.CtrlU:
                this.state.update("");
                break;
            case keymap_1.InputType.CtrlK:
                this.state.editDeleteEndOfLine();
                break;
            case keymap_1.InputType.CtrlQ:
                this.pauseHandler(true);
                break;
            case keymap_1.InputType.CtrlL:
                this.state.clearScreen();
                break;
            case keymap_1.InputType.Home:
            case keymap_1.InputType.CtrlA:
                this.state.moveCursorHome();
                break;
            case keymap_1.InputType.End:
            case keymap_1.InputType.CtrlE:
                this.state.moveCursorEnd();
                break;
            case keymap_1.InputType.Backspace:
                this.state.editBackspace(1);
                break;
            case keymap_1.InputType.Delete:
            case keymap_1.InputType.CtrlD:
                this.state.editDelete(1);
                break;
            case keymap_1.InputType.ArrowLeft:
                this.state.moveCursorBack(1);
                break;
            case keymap_1.InputType.ArrowRight:
                this.state.moveCursorForward(1);
                break;
            case keymap_1.InputType.ArrowUp:
                this.state.moveCursorUp(1);
                break;
            case keymap_1.InputType.ArrowDown:
                this.state.moveCursorDown(1);
                break;
            case keymap_1.InputType.UnsupportedControlChar:
            case keymap_1.InputType.UnsupportedEscape:
                break;
        }
    }
}
exports.Readline = Readline;
//# sourceMappingURL=readline.js.map