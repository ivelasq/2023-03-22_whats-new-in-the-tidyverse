"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.State = exports.Layout = exports.Position = void 0;
/* tslint:disable:max-classes-per-file */
const line_1 = require("./line");
const string_width_1 = __importDefault(require("string-width"));
class Position {
    constructor(rows, cols) {
        if (rows !== undefined) {
            this.row = rows;
        }
        else {
            this.row = 0;
        }
        if (cols !== undefined) {
            this.col = cols;
        }
        else {
            this.col = 0;
        }
    }
}
exports.Position = Position;
class Layout {
    constructor(promptSize) {
        this.promptSize = promptSize;
        this.cursor = new Position();
        this.end = new Position();
    }
}
exports.Layout = Layout;
class State {
    constructor(prompt, tty, highlighter, history) {
        this.line = new line_1.LineBuffer();
        this.highlighting = false;
        this.prompt = prompt;
        this.tty = tty;
        this.highlighter = highlighter;
        this.history = history;
        this.promptSize = tty.calculatePosition(prompt, new Position());
        this.layout = new Layout(this.promptSize);
    }
    buffer() {
        return this.line.buffer();
    }
    shouldHighlight() {
        const highlighting = this.highlighter.highlightChar(this.line.buf, this.line.pos);
        if (highlighting) {
            this.highlighting = true;
            return true;
        }
        else if (this.highlighting) {
            this.highlighting = false;
            return true;
        }
        else {
            return false;
        }
    }
    clearScreen() {
        this.tty.clearScreen();
        this.layout.cursor = new Position();
        this.layout.end = new Position();
        this.refresh();
    }
    editInsert(text) {
        const push = this.line.insert(text);
        const multiline = text.includes("\n");
        if (push && !multiline) {
            const width = (0, string_width_1.default)(text);
            if (width > 0 &&
                this.layout.cursor.col + width < this.tty.col &&
                !this.shouldHighlight()) {
                this.layout.cursor.col += width;
                this.layout.end.col += width;
                this.tty.write(text);
            }
            else {
                this.refresh();
            }
        }
        else {
            this.refresh();
        }
    }
    update(text) {
        this.line.update(text, text.length);
        this.refresh();
    }
    editBackspace(n) {
        if (this.line.backspace(n)) {
            this.refresh();
        }
    }
    editDelete(n) {
        if (this.line.delete(n)) {
            this.refresh();
        }
    }
    editDeleteEndOfLine() {
        if (this.line.deleteEndOfLine()) {
            this.refresh();
        }
    }
    refresh() {
        const newLayout = this.tty.computeLayout(this.promptSize, this.line);
        this.tty.refreshLine(this.prompt, this.line, this.layout, newLayout, this.highlighter);
        this.layout = newLayout;
    }
    moveCursorBack(n) {
        if (this.line.moveBack(n)) {
            this.moveCursor();
        }
    }
    moveCursorForward(n) {
        if (this.line.moveForward(n)) {
            this.moveCursor();
        }
    }
    moveCursorUp(n) {
        if (this.line.moveLineUp(n)) {
            this.moveCursor();
        }
        else {
            this.previousHistory();
        }
    }
    moveCursorDown(n) {
        if (this.line.moveLineDown(n)) {
            this.moveCursor();
        }
        else {
            this.nextHistory();
        }
    }
    moveCursorHome() {
        if (this.line.moveHome()) {
            this.moveCursor();
        }
    }
    moveCursorEnd() {
        if (this.line.moveEnd()) {
            this.moveCursor();
        }
    }
    moveCursorToEnd() {
        if (this.layout.cursor === this.layout.end) {
            return;
        }
        this.tty.moveCursor(this.layout.cursor, this.layout.end);
        this.layout.cursor = Object.assign({}, this.layout.end);
    }
    previousHistory() {
        if (this.history.cursor === -1 && this.line.length() > 0) {
            return;
        }
        const prev = this.history.prev();
        if (prev !== undefined) {
            this.update(prev);
        }
    }
    nextHistory() {
        if (this.history.cursor === -1) {
            return;
        }
        const next = this.history.next();
        if (next !== undefined) {
            this.update(next);
        }
        else {
            this.update("");
        }
    }
    moveCursor() {
        const cursor = this.tty.calculatePosition(this.line.pos_buffer(), this.promptSize);
        if (cursor === this.layout.cursor) {
            return;
        }
        if (this.shouldHighlight()) {
            this.refresh();
        }
        else {
            this.tty.moveCursor(this.layout.cursor, cursor);
            this.layout.promptSize = Object.assign({}, this.promptSize);
            this.layout.cursor = Object.assign({}, cursor);
        }
    }
}
exports.State = State;
//# sourceMappingURL=state.js.map