"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineBuffer = void 0;
class LineBuffer {
    constructor() {
        this.buf = "";
        this.pos = 0;
    }
    buffer() {
        return this.buf;
    }
    pos_buffer() {
        return this.buf.slice(0, this.pos);
    }
    // Return length of buffer in bytes
    length() {
        return this.buf.length;
    }
    // Return length of buffer in characters
    char_length() {
        return [...this.buf].length;
    }
    // Set text and position
    update(text, pos) {
        this.buf = text;
        this.pos = pos;
    }
    insert(text) {
        const shift = text.length;
        const push = this.pos === this.buf.length;
        if (push) {
            this.buf = this.buf + text;
        }
        else {
            this.buf = this.buf.slice(0, this.pos) + text + this.buf.slice(this.pos);
        }
        this.pos += shift;
        return push;
    }
    moveBack(n) {
        const pos = this.prevPos(n);
        if (pos !== undefined) {
            this.pos = pos;
            return true;
        }
        else {
            return false;
        }
    }
    moveForward(n) {
        const pos = this.nextPos(n);
        if (pos !== undefined) {
            this.pos = pos;
            return true;
        }
        else {
            return false;
        }
    }
    moveHome() {
        const start = this.startOfLine();
        if (this.pos > start) {
            this.pos = start;
            return true;
        }
        return false;
    }
    moveEnd() {
        const end = this.endOfLine();
        if (this.pos === end) {
            return false;
        }
        this.pos = end;
        return true;
    }
    startOfLine() {
        const start = this.buf.slice(0, this.pos).lastIndexOf("\n");
        if (start !== -1) {
            return start + 1;
        }
        else {
            return 0;
        }
    }
    endOfLine() {
        const end = this.buf.slice(this.pos).indexOf("\n");
        if (end !== -1) {
            return this.pos + end;
        }
        else {
            return this.buf.length;
        }
    }
    moveLineUp(n) {
        const off = this.buf.slice(0, this.pos).lastIndexOf("\n");
        if (off === -1) {
            return false;
        }
        const column = [...this.buf.slice(off + 1, this.pos)].length;
        let destStart = this.buf.slice(0, off).lastIndexOf("\n");
        if (destStart === -1) {
            destStart = 0;
        }
        else {
            destStart = destStart + 1;
        }
        let destEnd = off;
        for (let i = 1; i < n; i++) {
            if (destStart === 0) {
                break;
            }
            destEnd = destStart - 1;
            destStart = this.buf.slice(0, destEnd).lastIndexOf("\n");
            if (destStart === -1) {
                destStart = 0;
            }
            else {
                destStart = destStart + 1;
            }
        }
        const slice = [...this.buf.slice(destStart, destEnd)].slice(0, column);
        let gIdx = off;
        if (slice.length > 0) {
            gIdx = slice.map((c) => c.length).reduce((acc, m) => acc + m, 0);
            gIdx = destStart + gIdx;
        }
        this.pos = gIdx;
        return true;
    }
    moveLineDown(n) {
        const off = this.buf.slice(this.pos).indexOf("\n");
        if (off === -1) {
            return false;
        }
        let lineStart = this.buf.slice(0, this.pos).lastIndexOf("\n");
        if (lineStart === -1) {
            lineStart = 0;
        }
        else {
            lineStart += 1;
        }
        const column = [...this.buf.slice(lineStart, this.pos)].length;
        let destStart = this.pos + off + 1;
        let destEnd = this.buf.slice(destStart).indexOf("\n");
        if (destEnd === -1) {
            destEnd = this.buf.length;
        }
        else {
            destEnd = destStart + destEnd;
        }
        for (let i = 1; i < n; i++) {
            if (destEnd === this.buf.length) {
                break;
            }
            destStart = destEnd + 1;
            destEnd = this.buf.slice(destStart).indexOf("\n");
            if (destEnd === -1) {
                destEnd = this.buf.length;
            }
            else {
                destEnd = destStart + destEnd;
            }
        }
        const slice = [...this.buf.slice(destStart, destEnd)];
        if (column < slice.length) {
            this.pos =
                slice
                    .slice(0, column)
                    .map((c) => c.length)
                    .reduce((acc, m) => acc + m, 0) + destStart;
        }
        else {
            this.pos = destEnd;
        }
        return true;
    }
    // Set position of cursor
    set_pos(pos) {
        this.pos = pos;
    }
    // Return the position of the character preceding
    // pos
    prevPos(n) {
        if (this.pos === 0) {
            return undefined;
        }
        const buf = this.buf.slice(0, this.pos);
        return (this.pos -
            [...buf]
                .slice(-n)
                .map((c) => c.length)
                .reduce((acc, m) => acc + m, 0));
    }
    // Return the position of the character following the
    // current pos
    nextPos(n) {
        if (this.pos === this.buf.length) {
            return undefined;
        }
        const buf = this.buf.slice(this.pos);
        return (this.pos +
            [...buf]
                .slice(0, n)
                .map((c) => c.length)
                .reduce((acc, m) => acc + m, 0));
    }
    backspace(n) {
        const newPos = this.prevPos(n);
        if (newPos === undefined) {
            return false;
        }
        this.buf = this.buf.slice(0, newPos) + this.buf.slice(this.pos);
        this.pos = newPos;
        return true;
    }
    delete(n) {
        const nextChar = this.nextPos(n);
        if (nextChar !== undefined) {
            this.buf = this.buf.slice(0, this.pos) + this.buf.slice(nextChar);
            return true;
        }
        else {
            return false;
        }
    }
    deleteEndOfLine() {
        if (this.buf.length == 0 || this.pos == this.buf.length) {
            return false;
        }
        const start = this.pos;
        const end = this.endOfLine();
        if (start == end) {
            this.delete(1);
        }
        else {
            this.buf = this.buf.slice(0, start) + this.buf.slice(end);
        }
        return true;
    }
}
exports.LineBuffer = LineBuffer;
//# sourceMappingURL=line.js.map