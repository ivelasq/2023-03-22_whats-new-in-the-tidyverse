import { Terminal, ITerminalAddon } from "xterm";
import { Output, Tty } from "./tty";
import { Highlighter } from "./highlight";
type CheckHandler = (text: string) => boolean;
type CtrlCHandler = () => void;
type PauseHandler = (resume: boolean) => void;
export declare class Readline implements ITerminalAddon {
    private term;
    private highlighter;
    private history;
    private activeRead;
    private disposables;
    private watermark;
    private highWatermark;
    private lowWatermark;
    private highWater;
    private state;
    private checkHandler;
    private ctrlCHandler;
    private pauseHandler;
    constructor();
    /**
     * Activate this addon - this function is called by xterm's
     * loadAddon().
     *
     * @param term - The terminal this readline is attached to.
     */
    activate(term: Terminal): void;
    /**
     * Dispose
     *
     */
    dispose(): void;
    /**
     * Manually append a line to the top of the readline's history.
     *
     * @param text - The text to append to history.
     */
    appendHistory(text: string): void;
    /**
     * Set the highlighter handler for this readline. This is used to
     * create custom highlighting functionality (e.g. for syntax highlighting
     * or bracket matching).
     *
     * @param highlighter - A handler to handle all highlight callbacks.
     */
    setHighlighter(highlighter: Highlighter): void;
    /**
     * Set the check callback. This callback is used by readline to determine if input
     * requires additiona lines when the user presses 'enter'.
     *
     * @param fn - A function (string) -> boolean that should return true if the input
     *             is complete, and false if a line (\n) should be added to the input.
     */
    setCheckHandler(fn: CheckHandler): void;
    /**
     * Set the ctrl-c handler. This function will be called if ctrl-c is encountered
     * between readline reads. This may be used in circumstances where input from the
     * user may result in a long running task that can be cancelled.
     *
     * @param fn - The ctrl-c handler.
     */
    setCtrlCHandler(fn: CtrlCHandler): void;
    /**
     * Set the callback to be called when the user presses ctrl-s/ctrl-q.
     *
     * @param fn - The pause handler
     */
    setPauseHandler(fn: PauseHandler): void;
    /**
     * writeReady() may be used to implement basic output flow control. This function
     * will return false if the writes to the terminal initiated by Readline have
     * reached a highwater mark.
     *
     * @returns true if this terminal is accepting more input.
     */
    writeReady(): boolean;
    /**
     * Write text to the terminal.
     *
     * @param text - The text to write to the terminal.
     */
    write(text: string): void;
    /**
     * Write text to the terminal.
     *
     * @param text - The text to write to the terminal
     */
    print(text: string): void;
    /**
     * Write text to the terminal and append with "\r\n".
     *
     * @param text - The text to write to the terminal./
     * @returns
     */
    println(text: string): void;
    /**
     * Obtain an output interface to this terminal.
     *
     * @returns Output
     */
    output(): Output;
    /**
     * Obtain a tty interface to this terminal.
     *
     * @returns A tty
     */
    tty(): Tty;
    /**
     * Display the given prompt and wait for one line of input from the
     * terminal. The returned promise will be executed when a line has been
     * read from the terminal.
     *
     * @param prompt The prompt to use.
     * @returns A promise to be called when the input has been read.
     */
    read(prompt: string): Promise<string>;
    private handleKeyEvent;
    private readData;
    private readPaste;
    private readKey;
}
export {};
