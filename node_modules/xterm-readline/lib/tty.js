"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tty = void 0;
const string_width_1 = __importDefault(require("string-width"));
class Tty {
    constructor(col, row, tabWidth, out) {
        this.tabWidth = tabWidth;
        this.col = col;
        this.row = row;
        this.out = out;
    }
    write(text) {
        return this.out.write(text);
    }
    print(text) {
        return this.out.print(text);
    }
    println(text) {
        return this.out.println(text);
    }
    clearScreen() {
        this.out.write("\x1b[H\x1b[2J");
    }
    // Calculate the number of colums and rows required to print
    // text on a this.cols wide terminal starting at orig
    calculatePosition(text, orig) {
        const pos = Object.assign({}, orig);
        let escSeq = 0;
        [...text].forEach((c) => {
            if (c === "\n") {
                pos.row += 1;
                pos.col = 0;
                return;
            }
            let cw = 0;
            if (c === "\t") {
                cw = this.tabWidth - (pos.col % this.tabWidth);
            }
            else {
                let size;
                [size, escSeq] = width(c, escSeq);
                cw = size;
            }
            pos.col += cw;
            if (pos.col > this.col) {
                pos.row += 1;
                pos.col = cw;
            }
        });
        if (pos.col === this.col) {
            pos.col = 0;
            pos.row += 1;
        }
        return pos;
    }
    computeLayout(promptSize, line) {
        const newPromptSize = Object.assign({}, promptSize);
        const pos = line.pos;
        const cursor = this.calculatePosition(line.buf.slice(0, line.pos), promptSize);
        const end = pos === line.buf.length
            ? Object.assign({}, cursor) : this.calculatePosition(line.buf.slice(pos), cursor);
        const newLayout = {
            promptSize: newPromptSize,
            cursor,
            end,
        };
        return newLayout;
    }
    refreshLine(prompt, line, oldLayout, newLayout, highlighter) {
        const cursor = newLayout.cursor;
        const endPos = newLayout.end;
        this.clearOldRows(oldLayout);
        this.write(highlighter.highlightPrompt(prompt));
        this.write(highlighter.highlight(line.buf, line.pos));
        if (endPos.col === 0 &&
            endPos.row > 0 &&
            line.buf[line.buf.length - 1] !== "\n") {
            this.write("\n");
        }
        const newCursorRowMovement = endPos.row - cursor.row;
        if (newCursorRowMovement > 0) {
            this.write(`\x1b[${newCursorRowMovement}A`);
        }
        if (cursor.col > 0) {
            this.write(`\r\x1b[${cursor.col}C`);
        }
        else {
            this.write("\r");
        }
    }
    clearOldRows(layout) {
        const currentRow = layout.cursor.row;
        const oldRows = layout.end.row;
        const cursorRowMovement = Math.max(oldRows - currentRow, 0);
        if (cursorRowMovement > 0) {
            this.write(`\x1b[${cursorRowMovement}B`);
        }
        for (let i = 0; i < oldRows; i++) {
            this.write("\r\x1b[0K\x1b[A");
        }
        this.write("\r\x1b[0K");
    }
    moveCursor(oldCursor, newCursor) {
        if (newCursor.row > oldCursor.row) {
            // Move Down
            const rowShift = newCursor.row - oldCursor.row;
            if (rowShift === 1) {
                this.write("\x1b[B");
            }
            else {
                this.write(`\x1b[${rowShift}B`);
            }
        }
        else if (newCursor.row < oldCursor.row) {
            // Move Up
            const rowShift = oldCursor.row - newCursor.row;
            if (rowShift === 1) {
                this.write("\x1b[A");
            }
            else {
                this.write(`\x1b[${rowShift}A`);
            }
        }
        if (newCursor.col > oldCursor.col) {
            // Move Right
            const colShift = newCursor.col - oldCursor.col;
            if (colShift === 1) {
                this.write("\x1b[C");
            }
            else {
                this.write(`\x1b[${colShift}C`);
            }
        }
        else if (newCursor.col < oldCursor.col) {
            const colShift = oldCursor.col - newCursor.col;
            if (colShift === 1) {
                this.write("\x1b[D");
            }
            else {
                this.write(`\x1b[${colShift}D`);
            }
        }
        return;
    }
}
exports.Tty = Tty;
// Return the column width of text when printed
function width(text, escSeq) {
    if (escSeq === 1) {
        if (text === "[") {
            return [0, 2];
        }
        else {
            return [0, 0];
        }
    }
    else if (escSeq === 2) {
        if (!(text === ";" || (text[0] >= "0" && text[0] <= "9"))) {
            // unsupported
            return [0, 0];
        }
        return [0, escSeq];
    }
    else if (text === "\x1b") {
        return [0, 1];
    }
    else if (text === "\n") {
        return [0, escSeq];
    }
    else {
        return [(0, string_width_1.default)(text), escSeq];
    }
}
//# sourceMappingURL=tty.js.map